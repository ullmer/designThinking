
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Squares</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
      background: black;
    }
    @import url('https://fonts.googleapis.com/css2?family=Barlow:wght@700&display=swap');
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let width, height;

function resizeCanvas() {
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = canvas.height = Math.min(width, height);
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

const squareSize = canvas.width * 0.15;
const center = { x: canvas.width / 2, y: canvas.height / 2 };
let touchActive = false;

class Square {
  constructor(label, x, y) {
    this.label = label;
    this.baseX = x;
    this.baseY = y;
    this.x = x;
    this.y = y;
    this.color = 'darkpurple';
    this.isDragging = false;
    this.offsetX = 0;
    this.offsetY = 0;
    this.target = null;
    this.touchId = null;
    this.vibrationPhase = Math.random() * Math.PI * 2;
  }

  draw() {
    ctx.fillStyle = this.color === 'darkpurple' ? '#4B0082' : '#FF8C00';
    ctx.fillRect(this.x, this.y, squareSize, squareSize);
    ctx.font = `${squareSize * 0.5}px 'Barlow', sans-serif`;
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(this.label, this.x + squareSize / 2, this.y + squareSize / 2);
  }

  contains(mx, my) {
    return mx >= this.x && mx <= this.x + squareSize &&
           my >= this.y && my <= this.y + squareSize;
  }

  startDrag(mx, my, id) {
    this.isDragging = true;
    this.offsetX = mx - this.x;
    this.offsetY = my - this.y;
    this.color = 'darkorange';
    this.touchId = id;
  }

  drag(mx, my) {
    if (this.isDragging) {
      this.x = mx - this.offsetX;
      this.y = my - this.offsetY;
    }
  }

  endDrag() {
    this.isDragging = false;
    this.color = 'darkpurple';
    this.touchId = null;
    const dx = Math.abs(this.x + squareSize / 2 - center.x);
    const dy = Math.abs(this.y + squareSize / 2 - center.y);
    if (dx > dy) {
      this.target = { x: center.x - squareSize / 2, y: this.y };
    } else {
      this.target = { x: this.x, y: center.y - squareSize / 2 };
    }
  }

  update() {
    if (!touchActive && !this.isDragging && !this.target) {
      // Subtle vibration
      const amplitude = 1.5;
      this.x = this.baseX + Math.sin(Date.now() / 300 + this.vibrationPhase) * amplitude;
      this.y = this.baseY + Math.cos(Date.now() / 300 + this.vibrationPhase) * amplitude;
    }
    if (this.target) {
      const ease = 0.1;
      this.x += (this.target.x - this.x) * ease;
      this.y += (this.target.y - this.y) * ease;
      if (Math.abs(this.x - this.target.x) < 1 &&
          Math.abs(this.y - this.target.y) < 1) {
        this.x = this.target.x;
        this.y = this.target.y;
        this.target = null;
      }
    }
  }
}

let squares = [
  new Square('A', canvas.width * 0.2, canvas.height * 0.4),
  new Square('B', canvas.width * 0.6, canvas.height * 0.4)
];

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  squares.forEach(sq => {
    sq.update();
    sq.draw();
  });
  requestAnimationFrame(draw);
}
draw();

function reorderSquares() {
  if (!touchActive) {
    squares.sort((a, b) => a.label.localeCompare(b.label));
    squares[0].baseX = canvas.width * 0.2;
    squares[1].baseX = canvas.width * 0.6;
    squares.forEach(sq => {
      sq.baseY = canvas.height * 0.4;
    });
  }
}

canvas.addEventListener('mousedown', e => {
  const mx = e.offsetX, my = e.offsetY;
  touchActive = true;
  squares.forEach(sq => {
    if (sq.contains(mx, my)) {
      sq.startDrag(mx, my, null);
    }
  });
});

canvas.addEventListener('mousemove', e => {
  const mx = e.offsetX, my = e.offsetY;
  squares.forEach(sq => sq.drag(mx, my));
});

canvas.addEventListener('mouseup', () => {
  touchActive = false;
  squares.forEach(sq => sq.endDrag());
  reorderSquares();
});

canvas.addEventListener('touchstart', e => {
  touchActive = true;
  const rect = canvas.getBoundingClientRect();
  for (let touch of e.touches) {
    const mx = touch.clientX - rect.left;
    const my = touch.clientY - rect.top;
    squares.forEach(sq => {
      if (sq.contains(mx, my) && sq.touchId === null) {
        sq.startDrag(mx, my, touch.identifier);
      }
    });
  }
});

canvas.addEventListener('touchmove', e => {
  const rect = canvas.getBoundingClientRect();
  for (let touch of e.touches) {
    const mx = touch.clientX - rect.left;
    const my = touch.clientY - rect.top;
    squares.forEach(sq => {
      if (sq.touchId === touch.identifier) {
        sq.drag(mx, my);
      }
    });
  }
  e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchend', e => {
  touchActive = false;
  squares.forEach(sq => sq.endDrag());
  reorderSquares();
});
</script>
</body>
</html>
